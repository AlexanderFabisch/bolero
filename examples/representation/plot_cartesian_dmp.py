"""
===================
Cartesian Space DMP
===================

In a Cartesian Space DMP, the rotation are represented by quaternions. A normal
DMP cannot be used in this case because it requires that each component
can be linearly interpolated on its own, which is not the case for any
three-dimensional representation of orientation.

The following plot shows the trajectory generated by a Cartesian Space DMP
with random weights, start and goal positions, and orientations. Note that
executing such a DMP on a robot requires an inverse kinematic that computes
the required joint angles to reach the given poses. It is not guaranteed that
a smooth trajectory in Cartesian space will result in a smooth trajectory in
joint space.
"""
print(__doc__)

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from bolero.representation import CartesianDMPBehavior


def matrix_from_quaternion(q):
    w, x, y, z = q
    x2 = 2.0 * x * x
    y2 = 2.0 * y * y
    z2 = 2.0 * z * z
    xy = 2.0 * x * y
    xz = 2.0 * x * z
    yz = 2.0 * y * z
    xw = 2.0 * x * w
    yw = 2.0 * y * w
    zw = 2.0 * z * w

    R = np.array([[1.0 - y2 - z2,       xy - zw,       xz + yw],
                  [      xy + zw, 1.0 - x2 - z2,       yz - xw],
                  [      xz - yw,       yz + xw, 1.0 - x2 - y2]])

    return R


def plot_pose(ax, x, s=1.0, **kwargs):
    p = x[:3]
    R = matrix_from_quaternion(x[3:])
    for d, c in enumerate(["r", "g", "b"]):
        ax.plot([p[0], p[0] + s * R[0, d]],
                [p[1], p[1] + s * R[1, d]],
                [p[2], p[2] + s * R[2, d]], color=c, **kwargs)

    return ax


dmp = CartesianDMPBehavior(dt=0.001)
dmp.init(7, 7)

random_state = np.random.RandomState(0)
x0 = random_state.randn(3)
g = random_state.randn(3)
q0 = random_state.randn(4)
q0 /= np.linalg.norm(q0)
qg = random_state.randn(4)
qg /= np.linalg.norm(qg)

dmp.set_meta_parameters(["x0", "g", "q0", "qg"], [x0, g, q0, qg])

dmp.set_params(100.0 * random_state.randn(50 * 6))

X = dmp.trajectory()

ax = plt.subplot(111, projection="3d", aspect="equal")
plt.setp(ax, xlabel="X", ylabel="Y", zlabel="Z")
ax.plot(X[:, 0], X[:, 1], X[:, 2], lw=2, color="k")
for x in X[50:-50:50]:
    plot_pose(ax, x, s=0.3, lw=2, alpha=0.3)
plot_pose(ax, X[0], s=0.5, lw=3)
plot_pose(ax, X[-1], s=0.5, lw=3)
plt.show()
